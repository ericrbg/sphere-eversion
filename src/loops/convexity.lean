import analysis.convex.caratheodory
import analysis.convex.topology
import linear_algebra.affine_space.independent
import tactic.equiv_rw

noncomputable theory

/-!
# Convexity lemmas

This file gathers variations on Caratheodory's theorem for convex hulls.
-/

open set finset finite_dimensional
open_locale big_operators

section linear_algebra
open submodule
variables  {K : Type*}  [field K] {V : Type*} [add_comm_group V] [vector_space K V] -- [finite_dimensional K V] 
           {n : ‚Ñï} {v : fin n ‚Üí V} {Œπ : Type*}

lemma fintype.of_cardinal_lt {Œ± : Type*} (h : cardinal.mk Œ± < cardinal.omega) : fintype Œ± :=
classical.choice $ cardinal.lt_omega_iff_fintype.mp h

protected lemma finite_dimensional.fintype [finite_dimensional K V] {v : Œπ ‚Üí V} (hv : is_basis K v) : fintype Œπ :=
begin
  apply fintype.of_cardinal_lt,
  rw ‚Üê finite_dimensional.findim_eq_card_basis' hv,
  exact cardinal.nat_lt_omega _  
 end

/- -- useless here, but a big hole in the API
lemma finite_dimensional.linear_equiv_fin [finite_dimensional K V] : ((fin $ findim K V) ‚Üí K) ‚âÉ‚Çó[K] V :=
begin
  
  sorry
end -/

lemma linear_independent.rescale {v : Œπ ‚Üí V} (h : linear_independent K v) {w : Œπ ‚Üí K} (hw : ‚àÄ i, w i ‚â† 0) : linear_independent K (Œª i, w i ‚Ä¢ v i) :=
begin
  rw linear_independent_iff' at *,
  intros s g hg i hi,
  simp_rw smul_smul at hg,
  suffices : g i *w i = 0,
  { have := mul_eq_zero.mp this,
    tauto },
  exact h s (Œª i, g i * w i) hg i hi,
end

lemma submodule.mem_span_of_mem {R : Type*} [comm_ring R] {M : Type*} [add_comm_group M] [module R M] {s : set M}
  {x : M} (h : x ‚àà s) : x ‚àà span R s :=
subset_span h

lemma submodule.mem_span_range {R : Type*} [comm_ring R] {M : Type*} [add_comm_group M] [module R M] {Œπ : Type*}
  (f : Œπ ‚Üí M) (i : Œπ) : f i ‚àà span R (range f) :=
subset_span (mem_range_self i)

open submodule

lemma submodule.span_eq_of_subset {R M : Type*} [comm_ring R] [add_comm_group M] [module R M] {s t : set M}
  (h : s ‚äÜ span R t) (h' : t ‚äÜ span R s) : span R s = span R t :=
le_antisymm (span_le.mpr h) (span_le.mpr h')

lemma span_rescale {v : Œπ ‚Üí V} {w : Œπ ‚Üí K} (hw : ‚àÄ i, w i ‚â† 0) : span K (range $ Œª i, w i ‚Ä¢ v i)  = span K (range v) :=
begin
  apply submodule.span_eq_of_subset,
  { rintros _ ‚ü®i, rfl‚ü©,
      exact smul_mem _ _ (mem_span_range v i) },
  { rintros _ ‚ü®i, rfl‚ü©,
     suffices : w i ‚Ä¢ v i ‚àà span K (range $ Œª i, w i ‚Ä¢ v i),
     { have fact : (w i)‚Åª¬π ‚Ä¢ w i ‚Ä¢ v i ‚àà span K (range $ Œª i, w i ‚Ä¢ v i) := smul_mem _ _ (mem_span_range _ i),
       simpa [smul_smul, hw i] using fact, },
     exact mem_span_range _ i }  
end

lemma is_basis.rescale {v : Œπ ‚Üí V} (h : is_basis K v) {w : Œπ ‚Üí K} (hw : ‚àÄ i, w i ‚â† 0) : is_basis K (Œª i, w i ‚Ä¢ v i) :=
‚ü®h.1.rescale hw, by { rw span_rescale hw, exact h.2 }‚ü©

end linear_algebra

section affine

variables  {k : Type*}  [field k] {V : Type*} [add_comm_group V] [vector_space k V]
           {P : Type*} [affine_space k P]

-- This will turn out to be useless, but could still go to mathlib
lemma affine_independent_rescale {Œπ : Type*} {p : Œπ ‚Üí P} (hp : affine_independent k p) {w : Œπ ‚Üí k}
  (hw : ‚àÄ i, w i ‚â† 0) (i‚ÇÄ : Œπ) : affine_independent k (Œª i, (w i) ‚Ä¢ (p i -·µ• p i‚ÇÄ) +·µ• p i‚ÇÄ) :=
begin
  suffices : linear_independent k (Œª (i : {x // x ‚â† i‚ÇÄ}), w i ‚Ä¢ (p i -·µ• p i‚ÇÄ)),
    by simpa [affine_independent_iff_linear_independent_vsub k _ i‚ÇÄ],
  rw affine_independent_iff_linear_independent_vsub k _ i‚ÇÄ at hp,
  apply hp.rescale,
  tauto
end


end affine

section linear_algebra
variables {F : Type*} [add_comm_group F] [vector_space ‚Ñù F] 

lemma caratheodory' {P : set F} {x : F} (h : x ‚àà convex_hull P) : 
  ‚àÉ (p‚ÇÄ ‚àà P) (n : ‚Ñï) (v : fin n ‚Üí F) (w : fin n ‚Üí ‚Ñù), 
    linear_independent ‚Ñù v ‚àß
    (‚àÄ i, w i ‚àà (Ioc 0 1 : set ‚Ñù)) ‚àß
    (‚àÄ i, p‚ÇÄ + v i ‚àà P) ‚àß
    x = p‚ÇÄ + ‚àë i, w i ‚Ä¢ v i :=
sorry

end linear_algebra

open_locale topological_space

-- TODO : do a more general version using mem_nhds_iff_exists_Ioo_subset and a dense order
lemma real.exists_pos_of_mem_nhds_zero {s : set ‚Ñù} (h : s ‚àà (ùìù (0 : ‚Ñù))) : ‚àÉ Œµ : ‚Ñù, Œµ > 0 ‚àß Œµ ‚àà s :=
begin
  rcases metric.nhds_basis_ball.mem_iff.mp h with ‚ü®Œ¥, Œ¥_pos, hŒ¥‚ü©,
  use [Œ¥/2, by linarith],
  rw real.ball_eq_Ioo at hŒ¥,
  apply hŒ¥,
  simp ; split ; linarith
end

variables {F : Type*} [normed_group F] [normed_space ‚Ñù F]  [finite_dimensional ‚Ñù F]
local notation `d` := findim ‚Ñù F

lemma eq_center_mass_basis_of_mem_convex_hull {P : set F} {x : F}
  (hP : is_open P)
  (h : x ‚àà convex_hull P) : ‚àÉ (p‚ÇÄ : F) (v : fin d ‚Üí F) (w : fin d ‚Üí ‚Ñù), 
  x = p‚ÇÄ + ‚àë i, w i ‚Ä¢ v i ‚àß is_basis ‚Ñù v ‚àß (‚àÄ i, w i ‚àà (Icc 0 1 : set ‚Ñù)) ‚àß ‚àÄ i, p‚ÇÄ + v i ‚àà P :=
begin
  rcases caratheodory' h with ‚ü®p‚ÇÄ, p‚ÇÄ_in, n, v, w, hv, hw, h_in, h‚ü©,
  use p‚ÇÄ,
  rcases exists_sum_is_basis hv with ‚ü®Œπ, v', hvv'‚ü©,
  letI : fintype Œπ := begin
    letI : fintype (fin n ‚äï Œπ) := finite_dimensional.fintype hvv',
    exact fintype.of_injective (sum.inr : Œπ ‚Üí fin n ‚äï Œπ) (Œª _ _, sum.inr.inj)
  end,
  rcases finite_dimensional.equiv_fin hvv' with ‚ü®g, hg‚ü©,
  obtain ‚ü®Œµ, Œµ_pos, hŒµ‚ü© : ‚àÉ Œµ : ‚Ñù, Œµ > 0 ‚àß ‚àÄ i, p‚ÇÄ + Œµ ‚Ä¢ v' i ‚àà P,
  { let f : Œπ ‚Üí ‚Ñù ‚Üí F := Œª i t, p‚ÇÄ + t ‚Ä¢ v' i,
    have cont : ‚àÄ i, continuous (f i),
    { intros i,
      exact continuous_const.add (continuous_id.smul continuous_const) },
    have : ‚àÄ i, (f i) ‚Åª¬π' P ‚àà ùìù (0 : ‚Ñù),
    { intros i,
      apply (cont i).continuous_at,
      apply is_open_iff_mem_nhds.mp hP,
      convert p‚ÇÄ_in,
      simp [f] },
    simpa using real.exists_pos_of_mem_nhds_zero (filter.Inter_mem_sets_of_fintype this) },
  let v'' := (Œª i', Œµ ‚Ä¢ v' i'),
  refine ‚ü®sum.elim v v'' ‚àò g, sum.elim w (Œª i, 0) ‚àò g, _, _, _, _‚ü©,
  { change x = p‚ÇÄ + ‚àë i, ((Œª x, (sum.elim w (Œª (i : Œπ), 0) x) ‚Ä¢ (sum.elim v v'' x)) ‚àò g) i,
    rw [sum_equiv g, fintype.sum_sum_type],
    simp [h] },
  { suffices : is_basis ‚Ñù (sum.elim v v''), from this.comp _ g.bijective,
    let s : fin n ‚äï Œπ ‚Üí ‚Ñù := sum.elim (Œª i, 1) (Œª i, Œµ),
    have hs : ‚àÄ x, s x ‚â† 0, by rintros ‚ü®x‚ü© ; simp [s, ne_of_gt Œµ_pos],
    convert hvv'.rescale hs,
    ext ‚ü®x‚ü© ; simp [s, v''] },
  { simp_rw mem_Ioc at hw,
    equiv_rw g,
    simp,
    split,
    intro i, split ; linarith [(hw i).1, (hw i).2],
    norm_num },
  { equiv_rw g,
    simp [h_in],
    exact hŒµ },
end